### 超文本传输协议（ HTTP/1.1 ）：消息语构和路由

#### 摘要

超文本传输协议是一种为分布式的、协作化的超文本信息系统而设计的无状态应用层协议。本篇文档提供了 HTTP 结构和其相关术语的概述，定义了 “http” 和 “https” 统一资源标识符（URI）规范及 HTTP/1.1 信息语构和解析要求，并且描述了在实现上的相关安全注意事项。

#### 目录

* [x] [1. 引言](#1-引言)
  * [ ] [1.1 要求表示规范](#11-要求表示规范)
  * [ ] [1.2 语法表示规范](#12-语法表示规范)
* [ ] [2. 结构](#2-结构)
  * [ ] [2.1 客户端 / 服务器端消息传递](#21-客户端--服务器端消息传递)
  * [ ] [2.2 实现的多样性](#22-实现的多样性)
  * [ ] [2.3 中介](#23-中介)
  * [ ] [2.4 缓存](#24-缓存)
  * [ ] [2.5 一致性和错误处理](#25-一致性和错误处理)
  * [ ] [2.6 协议版本](#26-协议版本)
  * [ ] [2.7 统一资源标识符](#27-统一资源标识符)
     * [ ] [2.7.1 HTTP URI 格式](#271-http-uri-格式)
     * [ ] [2.7.2 HTTPS URI 格式](#272-https-uri-格式)
     * [ ] [2.7.3 HTTP 和 HTTPS URI 的正规化和匹配](#273-http-和-https-uri-的正规化和匹配)
* [ ] [3. 消息格式](#3-消息格式)
  * [ ] [3.1 起始行](#31-起始行)
     * [ ] [3.1.1 请求行](#311-请求行)
     * [ ] [3.1.2 状态行](#312-状态行)
  * [ ] [3.2 头字段](#32-头字段)
     * [ ] [3.2.1 字段的可扩展性](#321-字段的可扩展性)
     * [ ] [3.2.2 字段顺序](#322-字段顺序)
     * [ ] [3.2.3 空白](#323-空白)
     * [ ] [3.2.4 字段解析](#324-字段解析)
     * [ ] [3.2.5 字段限制](#325-字段限制)
     * [ ] [3.2.6 字段值的组成成分](#326-字段值的组成成分)
  * [ ] [3.3 消息体](#33-消息体)
     * [ ] [3.3.1 Transfer-Encoding](#331-transfer-encoding)
     * [ ] [3.3.2 Content-Length](#332-content-length)
     * [ ] [3.3.3 消息体的长度](#333-消息体的长度)
  * [ ] [3.4 处理不完整的消息](#34-处理不完整的消息)
  * [ ] [3.5 消息解析的鲁棒性](#35-消息解析的鲁棒性)


### 1. 引言

超文本传输协议（ HTTP ）是一种基于请求/响应模型的无状态应用层协议，它利用其极具拓展性的语义和具有自我描述性的消息内容来与基于网络的超文本信息系统进行灵活的交互。

本篇文档是系统性定义 HTTP/1.1 规范的系列文档中的第一份：

- [RFC-7230](https://tools.ietf.org/html/rfc7230) 消息语构和路由
- [RFC-7231](https://tools.ietf.org/html/rfc7231) 语义和内容
- [RFC-7232](https://tools.ietf.org/html/rfc7232) 条件请求
- [RFC-7233](https://tools.ietf.org/html/rfc7233) 范围请求
- [RFC-7234](https://tools.ietf.org/html/rfc7234) 缓存
- [RFC-7235](https://tools.ietf.org/html/rfc7235) 认证

这份 HTTP/1.1 规范使得 [RFC-2616](https://tools.ietf.org/html/rfc2616) 及 [RFC-2145](https://tools.ietf.org/html/rfc2145) 中关于 HTTP/1.1 的部分被废弃。同时本规范还更新了之前在 [RFC-2817](https://tools.ietf.org/html/rfc2817) 中被定义的“用 CONNECT 方法建立网络隧道”，而且定义了原先在 [RFC-2818](https://tools.ietf.org/html/rfc2818) 中被非正式性描述的 “https” URI 方案。

HTTP 是一种用于信息系统的通用接口协议。它被设计出以暴露出独立于所提供资源类型的统一接口给客户端的方式来隐藏服务的实现细节。同样地，服务器也不需要知道客户端的任何目的：一次 HTTP 请求可以被视作独立的而非与特定的客户端类型或一连串预定的请求步骤相关。这些特性造就了一个可以高效应用于许多场景并且允许客户端和服务端的实现随着时间推移独立发展的协议。

HTTP 也同样被设计来作为与其它非 HTTP 信息系统交流的中间协议。HTTP 代理（proxy）和网关（gateway）以把其它各种协议的信息服务内容转化为可供 HTTP 客户端获取并操作的超文本格式的方法来让我们可以使用这些服务。

这种灵活性导致的一个后果是，我们不能用术语定义 HTTP 协议里接口后面具体发生的事。我们同样很难去定义通讯的语法、获取资源的目的及接受者的预期行为。如果一次通讯被认为是独立的，那么成功的行为应当反映在服务器所提供观察接口的相应改变上。然而，考虑到可能有多个客户端正在并行请求且相互之间可能存在干扰，我们不能指望这样的改变能在单次响应之后被观察到。
> 原文是“we cannot require that
   such changes be observable beyond the scope of a single response.”，猜测是指，可能存在多个客户端请求同一个接口，所以在请求观察接口的时候，并不能确定刚才自己的请求是否为最后的一次请求（但为什么不用 Request ID 呢？欢迎大家讨论）。
   
本篇文档描述了在 HTTP 中被使用或者涉及的结构化的元素，定义了 “http” 和 “https” URI 规范，描述了总体的网络运转和连接管理，还定义了 HTTP 消息的构成及发送需求。我们的目的是定义所有独立于消息语义的关于 HTTP 消息处理的必要机制，从而为消息解析和消息转发中介定义完整的需求集。
   
#### 1.1 要求表示规范
#### 1.2 语法表示规范

### 2. 结构

#### 2.1 客户端 / 服务器端消息传递
#### 2.2 实现的多样性
#### 2.3 中介
#### 2.4 缓存
#### 2.5 一致性和错误处理
#### 2.6 协议版本
#### 2.7 统一资源标识符
##### 2.7.1 HTTP URI 格式
##### 2.7.2 HTTPS URI 格式
##### 2.7.3 HTTP 和 HTTPS URI 的正规化和匹配

### 3. 消息格式
#### 3.1 起始行
##### 3.1.1 请求行
##### 3.1.2 状态行
#### 3.2 头字段
##### 3.2.1 字段的可扩展性
##### 3.2.2 字段顺序
##### 3.2.3 空白
##### 3.2.4 字段解析
##### 3.2.5 字段限制
##### 3.2.6 字段值的组成成分
#### 3.3 消息体
##### 3.3.1 Transfer-Encoding
##### 3.3.2 Content-Length
##### 3.3.3 消息体的长度
#### 3.4 处理不完整的消息
#### 3.5 消息解析的鲁棒性



