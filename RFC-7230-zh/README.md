### 超文本传输协议（ HTTP/1.1 ）：消息语构和路由

#### 摘要

超文本传输协议是一种为分布式的、协作化的超文本信息系统而设计的无状态应用层协议。本篇文档提供了 HTTP 结构和其相关术语的概述，定义了 "http" 和 "https" 统一资源标识符（URI）规范及 HTTP/1.1 信息语构和解析要求，并且描述了在实现上的相关安全注意事项。

#### 目录

* [x] [1. 引言](#1-引言)
  * [x] [1.1 要求表示规范](#11-要求表示规范)
  * [x] [1.2 语法表示规范](#12-语法表示规范)
* [x] [2. 结构](#2-结构)
  * [x] [2.1 客户端 / 服务器端消息传递](#21-客户端--服务器端消息传递)
  * [x] [2.2 实现的多样性](#22-实现的多样性)
  * [ ] [2.3 中介](#23-中介)
  * [ ] [2.4 缓存](#24-缓存)
  * [ ] [2.5 一致性和错误处理](#25-一致性和错误处理)
  * [ ] [2.6 协议版本](#26-协议版本)
  * [ ] [2.7 统一资源标识符](#27-统一资源标识符)
     * [ ] [2.7.1 HTTP URI 格式](#271-http-uri-格式)
     * [ ] [2.7.2 HTTPS URI 格式](#272-https-uri-格式)
     * [ ] [2.7.3 HTTP 和 HTTPS URI 的正规化和匹配](#273-http-和-https-uri-的正规化和匹配)
* [ ] [3. 消息格式](#3-消息格式)
  * [ ] [3.1 起始行](#31-起始行)
     * [ ] [3.1.1 请求行](#311-请求行)
     * [ ] [3.1.2 状态行](#312-状态行)
  * [ ] [3.2 头字段](#32-头字段)
     * [ ] [3.2.1 字段的可扩展性](#321-字段的可扩展性)
     * [ ] [3.2.2 字段顺序](#322-字段顺序)
     * [ ] [3.2.3 空白](#323-空白)
     * [ ] [3.2.4 字段解析](#324-字段解析)
     * [ ] [3.2.5 字段限制](#325-字段限制)
     * [ ] [3.2.6 字段值的组成成分](#326-字段值的组成成分)
  * [ ] [3.3 消息体](#33-消息体)
     * [ ] [3.3.1 Transfer-Encoding](#331-transfer-encoding)
     * [ ] [3.3.2 Content-Length](#332-content-length)
     * [ ] [3.3.3 消息体的长度](#333-消息体的长度)
  * [ ] [3.4 处理不完整的消息](#34-处理不完整的消息)
  * [ ] [3.5 消息解析的鲁棒性](#35-消息解析的鲁棒性)


### 1. 引言

超文本传输协议（ HTTP ）是一种基于请求/响应模型的无状态应用层协议，它利用其极具拓展性的语义和具有自我描述性的消息内容来与基于网络的超文本信息系统进行灵活的交互。

本篇文档是系统性定义 HTTP/1.1 规范的系列文档中的第一份：

- [RFC-7230](https://tools.ietf.org/html/rfc7230) 消息语构和路由
- [RFC-7231](https://tools.ietf.org/html/rfc7231) 语义和内容
- [RFC-7232](https://tools.ietf.org/html/rfc7232) 条件请求
- [RFC-7233](https://tools.ietf.org/html/rfc7233) 范围请求
- [RFC-7234](https://tools.ietf.org/html/rfc7234) 缓存
- [RFC-7235](https://tools.ietf.org/html/rfc7235) 认证

这份 HTTP/1.1 规范使得 [RFC-2616](https://tools.ietf.org/html/rfc2616) 及 [RFC-2145](https://tools.ietf.org/html/rfc2145) 中关于 HTTP/1.1 的部分被废弃。同时本规范还更新了之前在 [RFC-2817](https://tools.ietf.org/html/rfc2817) 中被定义的"用 CONNECT 方法建立网络隧道"，而且定义了原先在 [RFC-2818](https://tools.ietf.org/html/rfc2818) 中被非正式性描述的 "https" URI 方案。

HTTP 是一种用于信息系统的通用接口协议。它被设计出以暴露出独立于所提供资源类型的统一接口给客户端的方式来隐藏服务的实现细节。同样地，服务器也不需要知道客户端的任何目的：一次 HTTP 请求可以被视作独立的而非与特定的客户端类型或一连串预定的请求步骤相关。这些特性造就了一个可以高效应用于许多场景并且允许客户端和服务端的实现随着时间推移独立发展的协议。

HTTP 也同样被设计来作为与其它非 HTTP 信息系统交流的中间协议。HTTP 代理（proxy）和网关（gateway）以把其它各种协议的信息服务内容转化为可供 HTTP 客户端获取并操作的超文本格式的方法来让我们可以使用这些服务。

这种灵活性导致的一个后果是，我们不能用术语定义 HTTP 协议里接口后面具体发生的事。我们同样很难去定义通讯的语法、获取资源的目的及接受者的预期行为。如果一次通讯被认为是独立的，那么成功的行为应当反映在服务器所提供观察接口的相应改变上。然而，考虑到可能有多个客户端正在并行请求且相互之间可能存在干扰，我们不能指望这样的改变能在单次响应之后被观察到。
> 原文是"we cannot require that
   such changes be observable beyond the scope of a single response."，猜测是指，可能存在多个客户端请求同一个接口，所以在请求观察接口的时候，并不能确定刚才自己的请求是否为最后的一次请求（但为什么不用 Request ID 呢？欢迎大家讨论）。
   
本篇文档描述了在 HTTP 中被使用或者涉及的结构化的元素，定义了 "http" 和 "https" URI 规范，描述了总体的网络运转和连接管理，还定义了 HTTP 消息的构成及发送需求。我们的目的是定义所有独立于消息语义的关于 HTTP 消息处理的必要机制，从而为消息解析和消息转发中介定义完整的需求集。
   
#### 1.1 要求表示规范

本文档中的关键词 " MUST "、" MUST NOT "、" REQUIRED "、" SHALL "、" SHALL NOT "、" SHOULD "、" SHOULD NOT "、" RECOMMENDED "、" MAY "和" OPTIONAL " 应依照 [RFC2119](https://tools.ietf.org/html/rfc2119) 中的描述，本译文不会翻译这些关键词。

有关错误处理的一致性标准和注意事项会在 [Section 2.5](#25-一致性和错误处理) 中定义。
#### 1.2 语法表示规范

这份规范使用[扩充巴科斯范式（ ABNF ）](https://tools.ietf.org/html/rfc5234)作为主要的语法表示规范。另外，在 [Section 7]() 中定义了一个 ABNF 的列表扩展符号 ‘ # ’ 操作符（与 ‘ * ’ 操作符表示重复的形式类似），它允许紧凑定义的、由逗号分隔的列表。

[Appendix B]() 展示了所有本文档中收录的全由标准 ABNF 所表示语法 （原文"  Appendix B shows the collected grammar with all list operators
   expanded to standard ABNF notation.
 "，不知如何解释？）

下列核心规则都可供参考，如同 [RFC5234, Appendix B.1](https://tools.ietf.org/html/rfc5234#appendix-B.1) 中的定义：ALPHA（字母），CR（回车），CRLF（CR LF），CTL（control 键），DIGIT（数字 0-9），DQUOTE（双引号），HEXDIG（十六进制数 0-9/A-F/a-f），HTAB（水平 Tab），LF（换行），OCTET（字节），SP（空格）和 VCHAR（任何可见的 USASCII 字符）。

作为惯例，以 "obs-" 开头的 ABNF 规则表示已经废弃的语法规则。
### 2. 结构

HTTP 是为万维网（ WWW ）的建设而生的，为了支持世界范围的超文本信息系统的可拓展性需求，它也在不断地发展。HTTP 的大部分结构都反映在它的术语和语构上。

#### 2.1 客户端 / 服务器端消息传递

HTTP 是一种无状态的请求/响应协议，它通过一个可靠的传输层或会话层"连接"交换信息。一个 HTTP 客户端（ Client ）是一个为了发送一个或多个 HTTP 请求（ Request ）而与服务器建立连接的应用程序。一个 HTTP 服务器（ Server ）是一个接收 HTTP 请求并发送 HTTP 响应（ Response ）来提供服务的应用程序。 

术语**"Client（客户端）"**和 **"Server（服务器）"**仅仅指代应用程序的某个特定连接。同一个程序可能同时在一些连接中扮演客户端而在另一些连接中扮演服务器。术语**"User Agent（用户代理）"**指代任何可以发起 HTTP 请求的的应用程序，包含但不仅限于：浏览器、爬虫、命令行工具、定制应用和手机 APP。术语**"Origin Server（源服务器）"**指代可以正确响应并返回目标资源的应用程序。术语**"Sender（发送者）"** 和 **"Recipient（接收者）"**分别指代任何发送或接收某条指定消息的实现。（原文" The
   terms "sender" and "recipient" refer to any implementation that sends
   or receives a given message, respectively. " 如何理解？）
   
HTTP 依赖统一资源标识符（ URI ）标准 [RFC 3986](https://tools.ietf.org/html/rfc3986) 来标识目标资源 [Section 5.1]() 和资源之间的关系。消息以一种跟互联网邮件 [RFC 5322](https://tools.ietf.org/html/rfc5322) 及多用途互联网邮件扩展（ MIME ）[RFC 2045](https://tools.ietf.org/html/rfc2045) 相似的格式被发送（[Appendix A of RFC 7231](https://tools.ietf.org/html/rfc7231#appendix-A) 查看 HTTP 与 MIME 消息的不同点）。

大多数的 HTTP 通讯都从一个为了展示某些被一个 URI 标识的资源而发起的取回请求（ GET ）开始。在最简单的情况下，这个通讯可能只通过用户代理（ UA ）和源服务器（ O ）之间的单个连接（===）就能完成。

```
    request >
UA ====================================== O
                            < response
```
一个客户端发送一个报文形式的 HTTP 请求给服务器，一条请求报文以包含 Method（ HTTP 方法）、URI 和 Protocol Version（协议版本）的[请求行](#311-请求行)开始，请求行之后是由请求修饰符、客户端信息和表示元数据组成的[头字段](#32-头字段)，头字段由一个空行标志结束，最后就是包含有效载荷的[消息主体](#33-消息体)（如果有的话）。

一个服务器响应一个客户端请求通过返回一个或多个 HTTP 响应报文，每个报文都以一个包含 Protocol Version（协议版本），一个成功或失败的状态码和一个可读的状态语句的[状态行](#312-状态行)开始，之后可能会跟着由服务器信息、资源元数据和表示元数据组成的[头字段](#32-头字段)，头字段由一个空行标志结束，最后就是包含有效载荷的[消息主体](#33-消息体)（如果有的话）。

一个连接可能可以被用于多次请求/响应通讯，如 [Section 6.3]() 中定义。

下面的例子演示了一个典型的[ GET 请求](https://tools.ietf.org/html/rfc7231#section-4.3.1)的报文交换，URI 是 "http://www.example.com/hello.txt"：

客户端请求：

```
GET /hello.txt HTTP/1.1
User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3
Host: www.example.com
Accept-Language: en, mi
```

服务器响应

```
HTTP/1.1 200 OK
Date: Mon, 27 Jul 2009 12:28:53 GMT
Server: Apache
Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT
ETag: "34aa387-d-1568eb00"
Accept-Ranges: bytes
Content-Length: 51
Vary: Accept-Encoding
Content-Type: text/plain

Hello World! My payload includes a trailing CRLF.
```
#### 2.2 实现的多样性

当考虑 HTTP 的设计时，和容易陷入一个思维陷阱——认为所有的用户代理都是通用浏览器且所有的源服务器都是大型公共网站。现实并非如此，常见的用户代理包括家用设施、音响、电子秤、固件更新脚本、命令行工具、手机 APP 和各种形状大小的通讯工具。同样，常见的 HTTP 源服务器包括家用自动化单元、可配置的网络组件、办公机器、自动化机器人、新闻提要、交通摄像头、广告选择器以及视频交流平台。

术语**"User Agent"**不仅仅指可以在请求时直接与代理软件进行交互的人类用户。在很多情况下，一个用户代理被安装或者配置在后台运行然后储存结果用于之后的查看（或者仅仅储存有意义的子集或者错误信息）。比如说爬虫，就是典型的，给一个起始 URI 和配置就可以在遍历爬取整个互联网时遵循指定的行为。

HTTP 实现的多样性意味着不是所有的用户代理在考虑一些安全或隐私问题时都可以提供给用户交互式的建议或者充足的警告。在少数需要报告错误给用户的情况下，把报告写入错误控制台或者日志文件也是可接受的。同样地，需要用户确认的自动化行为可能会在用户处理之前被提前选择配置、运行时选项或者简单的不安全行为黑名单所解决；确认并不意味着会弹出一个用户界面或者打断当前进程，如果用户早就做出了选择的话。

#### 2.3 中介

HTTP 允许使用 Intermediaries（中介） 来发起链式请求。Intermediaries 一共有三种形式：Proxy（代理），Gateway（网关）和 Tunnel（隧道）。在某些情况下，一个单独的 intermediary 可能会同时扮演 Origin Server、Proxy、Gateway 或 Tunnel，并基于每一条原始请求来切换行为。

```

            >             >             >             >
       UA =========== A =========== B =========== C =========== O
                  <             <             <             <
```

上面这幅图演示了在 User Agent 和 Origin Server 之间的三个 intermediaries（ A、B 和C ）。一个请求或响应报文将会穿过四个单独的连接。一些 HTTP 通信的选项可能只会在某些连接上生效，比如最近的连接、没有隧道的临近节点、链的终端节点、或者所有节点间的连接。虽然这幅图是线性的，但每一个参与节点都可能同时在其它的链里面扮演其它的角色。比如 B 可能从 A 之外的很多客户端接收请求，同时又向 C 之外的其它服务器转发请求，且同时在处理 A 的请求。同样地，之后的请求可能会通过连接中的不同路径，常见于基于动态配置的负载均衡。

术语**"upstream（上游）"**和**"downstream（下游）"** 用于描述报文的流向：所有的报文都从上游流向下游。术语**"inbound（入站）"**和**"outbound（出站）"**用于描述请求的路由方向："inbound" 表示向着 Origin Server 方向，"outbound" 表示向着 User Agent 方向。

"Proxy" 是一种由客户端自己选择的消息转发代理，通常遵循本地配置文件的规则来接收关于一些 absolute URI 的请求并尝试以转换到 HTTP 接口的方式满足这些请求。一些转换是小菜一碟，比如仅仅改变 HTTP 请求的 URI，但在另一情况下，可能需要将流量转换到另一个完全不同的应用层协议。Proxies 经常用同一个 intermediary 代理一组 HTTP 请求，出于安全、注解服务或共享缓存的目的。
#### 2.4 缓存
#### 2.5 一致性和错误处理
#### 2.6 协议版本
#### 2.7 统一资源标识符
##### 2.7.1 HTTP URI 格式
##### 2.7.2 HTTPS URI 格式
##### 2.7.3 HTTP 和 HTTPS URI 的正规化和匹配

### 3. 消息格式
#### 3.1 起始行
##### 3.1.1 请求行
##### 3.1.2 状态行
#### 3.2 头字段
##### 3.2.1 字段的可扩展性
##### 3.2.2 字段顺序
##### 3.2.3 空白
##### 3.2.4 字段解析
##### 3.2.5 字段限制
##### 3.2.6 字段值的组成成分
#### 3.3 消息体
##### 3.3.1 Transfer-Encoding
##### 3.3.2 Content-Length
##### 3.3.3 消息体的长度
#### 3.4 处理不完整的消息
#### 3.5 消息解析的鲁棒性



